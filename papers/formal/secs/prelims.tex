\subsection{Preliminaries}

In order to understand the exact requirements under which our framework for approximate programming by example may be applied, we introduce some common notation.

One of the core properties of \approximatePBE is that we have some way of quantifying what approximate means.
A \textit{metric space}~\cite{textbook} is a set with a structure that allows us to measure this sense of approximate.
A metric space is defined as a pair $(M,d)$, where S is a set and $d:M \times M \to \reals$ is a distance metric between all elements in the set. 
To form a metric space, the metric $d$ must obey the properties:

\begin{enumerate}
  \item $d(x,y) = 0 \Leftrightarrow x = y$ - identity of indiscernibles
  \item $d(x,y)  = d(y,x)$ - symmetry
  \item $d(x,z) \le d(x,y) + d(y, z)$ - triangle inequality
\end{enumerate}

We will use context-free, parameterized grammars to capture the types of programs we will synthesize.
The formalization of a grammar will allow us to describe how we refine how search space during the synthesis procedure.
A \textit{grammar} $G$ is defined as a tuple $(N,\Sigma,\productionRules,S)$.
The $\nonterminals$ and $\terminals$ denote sets of the nonterminal and terminal symbols of the grammar respectively.
a nonterminals $\nonterminals$ may be either a string constant, or a string constant parameterized with constants $\constants$ that are restricted to a range of continuous values $\reals$.
We write $X\ [a,b]^2 \ [c,d]$ to denote a nonterminal string constant $X$ with two constants over the range $[a,b]$ and one constant over the range $[c,d]$,

The set of production rules, $\productionRules$, define how an expression of terminals and nonterminals on the left-hand side are transformed into a new expression on the right-hand side, $LHS \to RHS$.
The left-hand side, $LHS = (\terminals \cup \nonterminals)^{*} \ \nonterminals \ \ (\terminals \cup \nonterminals)^{*}$, must contain at least one terminal, 
  and may be transformed on the right-hand side into any sequence of terminals and nonterminals $RHS = (\terminals \cup \nonterminals)^{*}$, including the empty string $\epsilon$.
The type of production rules can also be written in set notation $\productionRules :: \{(LHS,\{RHS\})\}$.
The last part of the tuple, $S$ denotes the starting symbol of this generative grammar $G$.

For convenience of notation, we introduce the type symbol $\typeOfGrammar = (N,\Sigma,\productionRules,S)$ to denote the type of a grammar that is constructed as above.
The language of a grammar $\languageOf{G}$ is the set of all words that can be generated by the grammar $G$, where each word is the concatenation of some number of terminal symbols $\terminals^{*}$.
In our context of \approximatePBE, $\languageOf{G}$ is the set of all syntactically well-formed programs.

%\markk{The work in~\cite{zhu2012randomized} uses a dataflow based model of computation. That model is too restricted for us, but maybe we can use something like that instead of grammars, which are very general?}


