\section{Introduction}

The great proliferation of computer music programming languages points to the difficulty of building a natural interface for users that want to computationally interact with musical data.
Programming applications in the domain of computer music, and specifically digital signal processing (DSP), requires that users not only grasp fundamental programming techniques, but also have a large domain specific knowledge on time and signal manipulations.
The amount of prerequisite skill and effort to overcome these barriers is often higher than many users are able to commit.

Furthermore, the difficult of programming DSP applications is often not commensurate with the creative intentions.
From a musical perspective, take the following simple use-case: a user hears a sample in a piece of music, and later in that piece hears the same sample with some added effects.
Now the user wishes to apply this same effect to their own sample.
In order to recreate this effect on a new sample, the user will have to reprogram the filter from the scratch.
This process will involve writing code, testing the code, listening to the original example, and constantly tweaking parameter values.

To simplify this process, we introduce \textit{DSP programming by example} (DSP-PBE).

We first explain the concept of programming by example~\cite{cypher93,lieberman01,synasc12}.
Programming by example (PBE) is a synthesis technique that automatically generates programs that coincide with given examples. An example is specified as a tuple of input and output values. Given a set $S= \{(i_1, o_1),\ldots, (i_n, o_n)\}$ of input/output examples, the goal is to automatically derive a program $P$ such that for every $j$, $P(i_j) = o_i$. 
Instead of writing code, the user provides a list of relevant examples and the synthesis tool automatically generates a program. In this way, the examples can be seen as an easily readable and understandable specification. However, even if the synthesized program satisfies all the provided examples, it still might not correspond to the user's intentions. Examples are, by nature, an incomplete specification.


PBE is a promising research direction that enables easy manipulation of data even for non-programmers~\cite{GulwaniHS12}. Recent work in this area has focused on manipulating fundamental data types such as strings~\cite{flashFillPOPL,vldb12,icml13}, lists~\cite{FeserCD15,poseraZ15} and numbers~\cite{cav12}. The success and impact of this line of work can be estimated from the fact that some of this technology~\cite{flashFillPOPL} ships as part of the popular Flash Fill feature in Excel 2013~\cite{flashfill}.


In DSP programming by example, a user directly provides an input sound sample and an output sound sample, and a DSP-PBE tool will automatically construct the required program that represents a DSP filter that can transform the input sound into the output sound.

\iffalse

\subsection{Program Synthesis}
Programming by example, and program synthesis more generally, has experienced an explosion of research and progress in the last 15 years within the formal logic research community.
This has led to real world applications, such as FlashFill, a programming by example plugin for Microsoft Excel~\cite{Gulwani2011}.

\fi

\subsection{DSP Programming Languages}

DSP programming languages provide users with an interface to build signal processing programs in domain specific languages.
The core feature of DSP languages we are interested in this work is the construction of DSP filters.
A DSP filter is, broadly speaking, any program that transforms a waveform from one form to another.
Examples of filters include a low-pass fitler, which allows frequencies below some frequency threshold; or a ring file


\subsection{Related Work}
\cmark{I think this should go first for this paper}

Spectral analysis and resynthesis is a powerful combination of tools that allows users to decompose a sound into its spectrograph, and build a synthesizer to create a similar sound~\cite{?}.
The limitation here is that resynthesis builds a generative synthesizer, which does not take into account any information about the components used to create the original sound.
While this technique is great for creating new instruments, we instead focus specifically on creating new filters.
