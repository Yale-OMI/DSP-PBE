\section{Search}
\label{sec:search}

Search techniques for programming by example have been the subject of intense research~\cite{?,?,?}.
As the search space of possible program is extremely large, search procedures must be exceptionally efficient. 
As a first foray into DSP-PBE, we restrict ourselves to only synthesizing low-pass and high-pass filters.
These two filters have the key property that they are quasi-commutative - when the thresholds of these filters do not overlap, applying a low-pass and then a high-pass is the same as applying a high-pass and then a low-pass.
We leave the exploration of non-commutative filters (for example, delay lines or ring filters) to future work.

\subsection{Gradient Descent}

One trouble with this approach is that we have lots of local minimums in the space of optimization.
Take the example of trying to learn a low-pass filter threshold.
If our initial threshold is too low (cutting off too much), and just on the other side of the threshold is a frequency we need, SGD will easily send us in that direction.
However, if the spectrogram of waveform has a frequency spectrum that is mostly inactive, SGD will detect a plateau and tell us we have found a global minimum, when in fact we are stuck in a local minimum.
We may be able to use some randomized restarting to hop over these.

\subsection{Refinement Type Driven Synthesis}

In order to find an initial value for gradient descent, we can use refinement types.
The use of formal methods in music has been explored previously~i
Refinement types are a way of giving an abstract description of the behavior of a function. 
For example, we given the function 
%
\texttt{map::[a]} $\to$ \texttt{[b]}
%
we can further provide a refinement types that captures some properties of the behavior of this function:

\texttt{f::xs:[a]} $\,\to\,$ \texttt{ys:[b]} \textbar \texttt{ length xs == length ys}

\noindent In this case, the refinement type describes that the length of the lists are still equal after applying the \texttt{map} function.

In a similar style for DSP, we can write predicates about the filters available to us during synthesis. 
For example, a low-pass filter could be described as the refinement type that says the amplitude of the frequencies greater than the threshold frequency have decreased in the output Audio.

\texttt{lpf::t:Float} $\,\to\,$  \texttt{xs:Audio} $\,\to\,$ \texttt{ys:Audio} \textbar
\texttt{ ($\forall$$f_1$ $\in$ spectrogram(xs)}, \texttt{ $\forall$$f_2$ $\in$ spectrogram(ys))}:  \centerline{\texttt{(}$f_1$ $\textgreater$ \texttt{t}  $\land$  $f_2$ $\textgreater$ \texttt{t}  $\land$  $f_1$ == $f_2$ $\implies$ \texttt{(amp($f_1$) $\textgreater$ amp($f_2$))}} ~\\
Where \texttt{t} represents the level at which the lowpass filter is applied, \texttt{spectrogram} represents the spectrogram of the sound sample, $f_i$ represents a frequency, and \texttt{amp()} represents the amplitude of the frequency. This refinement type can be abbreviated into \texttt{$r_{lpf}$(t, xs, ys)}, a predicate on a threshold frequency \texttt{t} and the two audio files \texttt{xs, ys}. \\ \\
Additionally, a high-pass filter could be described as the refinement type that says the amplitude of the frequencies less than the threshold frequency have decreased in the output Audio. \\

\centerline{ \texttt{hpf::t:Float} $\,\to\,$  \texttt{xs:Audio} $\,\to\,$ \texttt{ys:Audio} \textbar }
\centerline{\texttt{ ($\forall$$f_1$ $\in$ spectrogram(xs)}, \texttt{ $\forall$$f_2$ $\in$ spectrogram(ys))}: } \centerline{($f_1$ $\textless$ \texttt{t}  $\land$  $f_2$ $\textless$ \texttt{t}  $\land$  $f_1$ == $f_2$ $\implies$ \texttt{(amp($f_1$) $\textgreater$ amp($f_2$))}} ~\\
Where \texttt{t} represents the level at which the highpass filter is applied, \texttt{spectrogram} represents the spectrogram of the sound sample, $f_i$ represents a frequency, and \texttt{amp()} represents the amplitude of the frequency. This refinement type can be abbreviated into \texttt{$r_{hpf}$(t, xs, ys)}, a predicate on a threshold frequency \texttt{t} and the two audio files \texttt{xs, ys}.

\subsection{Combination of Search Algorithms}

One hypothesis as to how we would combine both algorithms would be through a feedback loop. We will use the refinement types to select a filter with a parameter. We then send that information into gradient descent to find a more precise filter representation (more accurate parameter measure). We will then apply this filter with the new parameter value from gradient descent to the input sound sample. Next, we will send this new sound sample $(F(I))$ and the original output sound sample $(O)$ to the aural distance function \texttt{dist}. If the \texttt{dist} function returns a value lower than the threshold distance given by us or the user, then we will accept that filter and return it to the user. If it is not, we will attempt to refine our parameter for the filter. An example of this can be seen in the diagram below: 

%\begin{figure}[!htb]
%\centerline{\includegraphics[width=\textwidth]{CPSC2}}
%\caption{Flow diagram of the DSP-PBE Synthesizer}\label{fig:image6}
%\end{figure}\\ 

This loop could become more complicated as multiple filters could be applied to one sound sample once the parameter has been tuned to the best value. This idea will be discussed later in this paper.

\subsubsection{Filter List}

For the DSP-PBE problem on sound samples, we will have a list of filters and corresponding refinement types. The goal for the filter list is to have enough variance in the filters in the list so that gradient descent can then refine the parameter for the filter (finding the global minimum and not getting caught at a local minimum), and no one value of the filter parameter will be overlooked. However, we are going to have to strike a balance between accuracy and length of filter list because the longer the filter list is, the longer it will take to search through all of the filters and corresponding refinement types. As an example, a filter list with only low pass filters would look as below:

\begin{enumerate}
{\setlength\itemindent{150pt} \item{\texttt{lpf($\delta$, xs, ys)}}}
{\setlength\itemindent{150pt} \item{\texttt{lpf(2$\delta$, xs, ys)}}}
\end{enumerate}
\centerline{\bm{$\vdots$}} ~\\
Where $\delta$ is the smallest variance necessary for gradient descent to find the global minimum from this delta and not a local minimum, and the largest variance necessary so any two filters would not overlap. This delta will need to be discovered by practice. 

\subsubsection{Ordering of Refinement Types}

As stated above, the longer the filter list becomes, the longer it will take to search through the list to find a refinement type that holds with the spectrogram of the input and output sound samples. In order to combat this, we could order the filters accordingly, to decrease the time it takes to search through them. We could also attempt to increase the accuracy of the parameters for the filters we know hold on our sound samples. \\ \\
Let's take our filter list created above. For some $\delta$ not yet discovered, a filter list with only lowpass filters will look as follows:

\begin{enumerate}
{ \item{\texttt{lpf($\delta$, xs, ys)}}}
{ \item{\texttt{lpf(2$\delta$, xs, ys)}}}
\end{enumerate}
\centerline{\bm{$\vdots$}} 
\begin{enumerate}
{ \item{\texttt{lpf(maxf - 2$\delta$, xs, ys)}}}
{ \item{\texttt{lpf(maxf - $\delta$, xs, ys)}}}
\end{enumerate}
As stated above, we know a low-pass filter could be described by a refinement type stating that the amplitude of the frequencies greater than the threshold frequency value have decreased in the output Audio. For this reason, we know that if any lowpass filter is applied in our output sound sample, the refinement type with the greatest threshold frequency in our filter list will hold for our input and output spectrograms (in this case \texttt{lpf(maxf - $\delta$, xs, ys)}). Formally, we know: \\ \\
\centerline{\texttt{xs::Audio $\land$ ys::Audio $\land$ $r_{lpf}$(t, xs, ys) $\implies$}} \\
\centerline{\texttt{ $\forall$ t' $\textgreater$ t. $r_{lpf}$(t', xs, ys)}} ~\\
So, to attempt to decrease the number of filters tried, we could test the greatest threshold frequency lowpass filter in the filter list, and if it does not hold, we can skip all other lowpass filters in the list. The opposite would hold true for highpass filters: \\ \\
\centerline{\texttt{xs::Audio $\land$ ys::Audio $\land$ $r_{hpf}$(t, xs, ys) $\implies$}}\\
\centerline{\texttt{ $\forall$ t' $\textless$ t. $r_{hpf}$(t', xs, ys)}} ~\\
As we create more refinement types for other filters, we can create different orders to decrease the number of refinement types needed to test to find one that hold for our input and output spectrograms. \\ \\
If we want to increase the accuracy for our refinement types, the order for the filter list will need to be different. If we look at the example filter list above, we would want to start from the lowest threshold frequency filter in the list (\texttt{lpf($\delta$, xs, ys)}) and increase the threshold frequency level from there. This way, we won't skip over our threshold frequency at any point (and therefore end up with a local minimum in gradient descent rather than the global minimum). For highpass filters, we would again want to do the opposite of the lowpass filters and start with the highest threshold frequency value available and decrease that value when searching for the optimal threshold frequency level. Again, we would hopefully be able to make these optimizations with other filter/refinement type additions. This will be the easiest way to increase accuracy or decrease time (or a combination of both) to optimize our DSP-PBE tool.

\subsubsection{Application of Refinement Types}

Given our ordered filter list, we can update our flow chart from Figure~\ref{fig:image6}. The choice of a filter will depend on the order described in the previous section. First, we check the worst case scenario for each filter type. If the worst case scenario for one filter holds, then we go back and test the filters in the order that will correctly increase accuracy for that filter. Otherwise, we skip that filter type all together and move on to the next one. The flow chart below describes the choice of a refinement type from the filter list:
%\begin{figure}[!htb]
%\centerline{\includegraphics[scale = 0.55]{CPSC490FlowFLChoose}}
%\caption{Flow diagram of refinement type choice}\label{fig:image7}
%\end{figure}\\ 

Only after finding the correct refinement type parameter will we send that filter corresponding to it to gradient descent to further optimize the parameter. Finally, we check the aural distance of the filter on the input sound sample ($F(I)$) and the output sound sample ($O$), and complete the feedback loop according to the results. The updated flow chart is below:

%\begin{figure}[!htb]
%\centerline{\includegraphics[width=\textwidth]{CPSC}}
%\caption{Flow diagram of DSP-PBE Synthesizer with filter list}\label{fig:image8}
%\end{figure}

\begin{comment}
Once an order has been found that best optimizes the refinement type list, we then need to apply the refinement types. In order to apply the refinement type, we will go through our refinement type list and test each if each one holds true on the spectrogram of the input and output sound samples, skipping the ones accordingly as described above. We will start with the refinement types of the same type and check different parameter levels after that. Once we know a refinement type doesn't work, we can remove it from the list of refinement types. This will decrease the time it takes to look up refinement types if we need to apply more than one filter to our sound sample. Once we find a refinement type that works, we apply the filter corresponding to that refinement type to the input sound file and send that file to gradient descent. We will then come up with a threshold for the lowpass and highpass filter and send that threshold and filter to the aural distance function.
\end{comment}

\subsubsection{Combination of Refinement Types}

When applying refinement types and the filters corresponding to them, just one may not be enough. In this paper, we are keeping things simple with just lowpass and highpass filters. However, in theory, we could have a multitude of filters being applied over each other (ex. lowpass, delay, white noise, etc.). So, in order for DSP-PBE to work in practice, we need to be able to apply more than one filter to our sound sample and therefore, more than one refinement type to the spectrogram of that sound sample. \\ \\
We can first find any one filter that fits our parameters. For example, let's say a refinement type of a lowpass filter holds true. As described above, we will optimize this filter to have a threshold frequency closest to the actual threshold frequency of the output filter and send this filter and threshold frequency  to gradient descent. Gradient descent will hopefully find the global minimum and return a threshold frequency and filter to us ($F$). However, even though this optimized filter returned an answer, the aural distance between $F(I)$ and $O$ could still be greater than the aural distance threshold. So, next, we would need to try and decrease the aural distance between these two filters. One way we can do this is by adding another filter on top of $F(I)$. \\ \\
In order to do this, we must apply the filter that corresponds to the first refinement type used ($r_1$) to the input sound sample, creating a new sound sample, $s_{new}$ (where $s_{new}$ = $F(I)$). We must then return to our filter list and test different filters on $s_{new}$ as the input. The goal would be to see if any filter holds for $s_{new}$ as the input sound sample and the original output sound sample as the output. Basically, our new goal would be to find a new filter ($F_2$) such that \texttt{dist}$(F_2$$(F(I)), O)$\texttt{ = 0} or \texttt{dist}$(F_2$$(s_{new}), O)$\texttt{ = 0}. If a second filter is found (and coincidentally a second refinement type, $r_2$), then we will send the two filters used in conjunction to gradient descent, and then after, to the distance function, to see if they can return an aural distance below the threshold distance given by the user. \\ \\
The refinement type for a combination of filters and therefore a combination of refinement types would look as follows: \\

\centerline{$r_{combined}$:: \texttt{x:Audio} $\,\to\,$ \texttt{y:Audio} \textbar \texttt{ $\exists$z. $r_1$(x, z) $\land$ $r_2$(z, y)}} ~\\
where \texttt{z} is $s_{new}$, \texttt{x} is the original input sound sample, \texttt{y} is the output sound sample, $r_1$ is the first refinement type, and $r_2$ is the second refinement type. \\ \\
This process can be repeated as many times as necessary as many filters could be applied to an input sound sample to obtain the output sound sample. 
\begin{comment}
The new feedback loop would look something like this: \\
\includegraphics[width=\textwidth]{CPSC490Flow2.png}
\end{comment}




