
\section{Problem Statement}

One of the core challenges in applying programming by example for DSP is to quantify how close our synthesized solution is to the correct solution.
In this case, the closeness of two audio files is a subjective measure - we do not necessarily know what features of the input/output audio pair the user is trying to emulate.
We use as the distance function, $\distFxn$, between two audio files, an audio fingerprinting technique~\cite{SantolucitoFARM} that approximates a measure of how different two audio clips sound to the human ear.
This metric is focused on measuring the amplitudes of frequency peaks obtains from a sliding window FFT.

%
\begin{align*}
\sum_{t=0}^{ts}\ \sum_{i=0}^{p} euclid\Big(\ &peak(i,toC(x)@t), \\ &peak(i,toC(y)@t)\ \Big)
\end{align*}
%

While measuring frequency peaks require temporally aligned audio, this can be achieved with advances in dynamic time warping techniques for audio~\cite{carabias2015audio}.
To contain the scope of the DSP-PBE problem, we assume that the user has provided audio that is temporally aligned.
As a technical note, this also requires that the sample rates of the audio match, which again we assume the user handles for simplicity.

A \textit{metric space}~\cite{textbook} is a set with a structure that allows us to measure this sense of approximate.
A metric space is defined as a pair $(M,d)$, where S is a set and $d:M \times M \to \reals$ is a distance metric between all elements in the set. 
To form a metric space, the metric $d$ must obey the properties:

\begin{enumerate}
  \item $d(x,y) = 0 \Leftrightarrow x = y$ - identity of indiscernibles
  \item $d(x,y)  = d(y,x)$ - symmetry
  \item $d(x,z) \le d(x,y) + d(y, z)$ - triangle inequality
\end{enumerate}



This is not actually a metirc space. Here is an example of two audio files that violate the identity of indiscernibles property of a metric space.
However, this is a pathological examples and in most cases is close enough for us. 
We show that this is a metric space by running a set of tests of real world audio files

\subsection{Defining the search space}

In order to formalize the search space of DSP-PBE, we define a grammar of filters, as shown in Fig.~\ref{fig:grammar}.
This grammar defines the tree-like structure of all allowable DSP programs that our synthesis technique is able to find.
The grammar states that we may construct a DSP filter program, $DSP$, by composing programs in one of two ways.
We allow parallel composition with the $\arrComp$ operator, which indicates the two component programs share input, and their output is summed in the time domain.
We also allow sequential composition with the $\parallelCompose$ operator, which indicates that the first component program pipes its output audio to the next component program.
We additionally allow $Nodes$, which is the set of primitive filters avaible to synthesis.
This set can be expanded as needed by the user depending on the use case.
We limit the set of $Nodes$ here to a core set illustrating both commutative ($LFP, HPF, WN$) and noncommutative ($Reverb, PitchShift$) operators.
The app level for each node indicates amplitude scaling of the output.

\begin{figure}
\begin{flalign*}
DSP := & \\
& |\ DSP \arrComp DSP\ \qquad & \text{\color{gray} sequential composition} & \\
& |\ DSP \parallelCompose DSP\ & \text{\color{gray} parallel composition} &\\
& |\ Node & \\
Node := & & \\
& |\ LPF \ [0,20k] \ [0,1] &\text{\color{gray} threshold, app}\\
& |\ HPF \ [0,20k] \ [0,1] &\text{\color{gray} threshold, app}\\
& |\ Reverb \ [0,1] \ [0,1] \ [0,1] & \text{\color{gray} room size, mix, app}\\
& |\ PitchShift\ [-1,1] \ [0,1] & \text{\color{gray} pitch shift amount, app}\\
& |\ WN \ [0,1] \text{\color{gray} app}& 
\end{flalign*}
\caption{The grammar of DSP filters we consider}
\label{fig:grammar}
\end{figure}


