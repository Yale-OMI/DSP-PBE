
\section{Problem Statement}

One of the core challenges in applying programming by example for DSP is to quantify how close our synthesized solution is to the correct solution.
In this case, the closeness of two audio files is a subjective measure - we do not necessarily know what features of the input/output audio pair the user is trying to emulate.
We use as the distance function, $\distFxn$, between two audio files, an audio fingerprinting technique~\cite{SantolucitoFARM} that approximates a measure of how different two audio clips sound to the human ear in a similar style to audio fingerprinting~\cite{wang2003industrial,fingerprinting}.
This metric takes a sliding window FFT over time points $ts$, plot the constellation of amplitude and frequency peaks $p$, then takes the euclidean distance between the points of the constellation.

%
\begin{align*}
\distFxn(x,y) =  \sum_{t=0}^{ts}\ \sum_{i=0}^{p} euclid\Big(\ &peak(i,C(x)@t), \\ &peak(i,C(y)@t)\ \Big)
\end{align*}
%

While measuring frequency peaks require temporally aligned audio, this can be achieved with advances in dynamic time warping techniques for audio~\cite{carabias2015audio}.
To contain the scope of the DSP-PBE problem, we assume that the user has provided audio that is temporally aligned.
As a technical note, this also requires that the sample rates of the audio match and the amplitudes of the examples have been normalized.
Again we assume the user handles amplitude normalization and resampling to align sample rates as necessary for simplicity.

While the work of~\cite{SantolucitoFARM} shows that this distance metric obeys some properties (commutativity, musically motivated properties) that intuitively make sense for audio,
  we point to a weakness of this measure - that it does not obey the properties of a \textit{metric space}.
A metric space~\cite{frechet1906quelques} is defined as a pair $(A,d)$, where S is a set and $d:A \times A \to \reals$ is a distance metric between all elements in the set (in DSP-PBE, $A$ is an audio file).
To form a metric space, the metric $d$ must obey the properties:

\begin{enumerate}
  \item $d(x,y) = 0 \Leftrightarrow x = y$ - identity of indiscernibles
  \item $d(x,y)  = d(y,x)$ - symmetry
  \item $d(x,z) \le d(x,y) + d(y, z)$ - triangle inequality
\end{enumerate}

An easy counterexample to show that $\distFxn$ does not form a metric space are two audio files that are otherwise identical except for switching the amplitudes of the peaks of the first time slice.
These inputs then violate the ``identity of indiscernibles'' property of a metric space.
However, this is a pathological examples and in most cases $\distFxn$ is close enough for the purposes of DSP-PBE.
We leave the problem of finding an aural distance that forms a metric space to future work.
 

\subsection{Defining the search space}

In order to formalize the search space of DSP-PBE, we define a grammar of filters, as shown in Fig.~\ref{fig:grammar}.
This grammar defines the tree-like structure of all allowable DSP programs that our synthesis technique is able to find.
The grammar states that we may construct a DSP filter program, $DSP$, by composing programs in one of two ways.
We allow sequential composition with the $\arrComp$ operator, which indicates the two component programs share input, and their output is summed in the time domain.
We also allow parallel composition with the $\parallelCompose$ operator, which indicates that the first component program pipes its output audio to the next component program.
We additionally allow $Nodes$, which is the set of primitive filters available to synthesis.
This set can be expanded as needed by the user depending on the use case.
We limit the set of $Nodes$ here to a core set illustrating both commutative ($LFP, HPF, WN$) and noncommutative ($Reverb, PitchShift$) operators.
The app level for each node indicates amplitude scaling of the output.

\begin{figure}
\begin{flalign*}
DSP := & \\
& |\ DSP \arrComp DSP\ \qquad & \text{\color{gray} sequential composition} & \\
& |\ DSP \parallelCompose DSP\ & \text{\color{gray} parallel composition} &\\
& |\ Node & \\
Node := & & \\
& |\ LPF \ [0,20k] \ [0,1] &\text{\color{gray} threshold, app}\\
& |\ HPF \ [0,20k] \ [0,1] &\text{\color{gray} threshold, app}\\
& |\ Reverb \ [0,1] \ [0,1] \ [0,1] & \text{\color{gray} room size, mix, app}\\
& |\ PitchShift\ [-1,1] \ [0,1] & \text{\color{gray} pitch shift amount, app}\\
& |\ WN \ [0,1] &\text{\color{gray} app}
\end{flalign*}
\caption{The grammar of DSP filters we consider}
\label{fig:grammar}
\end{figure}


