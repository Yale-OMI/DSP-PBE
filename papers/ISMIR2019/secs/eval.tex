\section{Evaluation}

To evaluate our approach, we apply our synthesis algorithm to two sets of input/output examples.
The first set examines the effectiveness of the initial structure construction as described in Sec~\ref{sec:initStruct}.
The second benchmark set captures the use case of \ourTool where a user wants to model real world sounds.
This set consists of examples where the input is a trumpet without a mute, and the output examples are the same trumpet with various mutes.

\setlength{\tabcolsep}{0.9em}
\def\arraystretch{1.1}
\begin{table*}[t!]
\centering
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Input} & \textbf{Filter} & \textbf{Synthesized Filter} & \textbf{dist(o, $f$(i))} & \textbf{Time (sec)}
\csvreader{results/farm.csv}{}
{\\ \hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv & \csvcolvi}
\\ \hline
\end{tabular}
\caption{The process for initial structure construction helps guide the synthesis, especially of simple filters.}
\label{table:evalInit}
\end{table*}

The results of running \ourTool on the set of known filter benchmarks sounds are reported in Table~\ref{table:evalInit}.
Here we know the ``ground truth'' filter that was used to produce the output sound, and our synthesis is trying to reconstruct this filter from the examples.
The only filter nodes used here are LPF and HPF to demonstrate the effectiveness of the initial structural construction.

The results of running \ourTool  on the trumpet mute sounds benchmarks are reported in Table~\ref{table:eval}.
This table was generated with the maximum structural attempts set to 6 and the maximum metrical attempts per structure set to 5.

\begin{table*}[t!]
\centering
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Input} & \textbf{Output} & \textbf{dist(o, $f$(i))} & \textbf{Structural Attempts} & \textbf{Time (sec)}
\csvreader{results/trumpet.csv}{}
{\\ \hline \csvcoli & \csvcolii & \csvcoliv & \csvcolv & \csvcolvi}
\\ \hline
\end{tabular}
\caption{Evaluation on a set of benchmarks.}
\label{table:eval}
\end{table*}

\iffalse
\begin{table}
\begin{tabular}{|c|c|c|c|}
\hline
\makecell{\textbf{Metrical} \\ \textbf{Limit}} & \makecell{\textbf{Structural} \\ \textbf{Limit}} & \textbf{Score} & \textbf{Time}
\csvreader{results/timeout.csv}{}
{\\ \hline \csvcoliii & \csvcoliv & \csvcolvi & \csvcolviii}
\\ \hline
\end{tabular}
	\caption{\brandon{computing new results... this may end up not being interesting}}
\label{table:timeout}
\end{table}
\fi

\subsection{SuperCollider Program Generation}

The generated model is represented by a data structure as described in the grammar in Fig.~\ref{fig:grammar}. 
This model cannot be changed by the user, so we present means to translate the produced filter into executable SuperCollider code.
Each of the $Filter Nodes$ types, except for $WhiteNoise$, have a direct translation into corresponding SuperCollider UGens. 
$WhiteNoise$ requires the addition of an implicit $Mix$ UGen, which mixes the incoming signal with the signal generated by the $WhiteNoise$ UGen.
The tree of $Filter\ Nodes$ generated by the synthesis algorithm is recursively traversed, and each $Node$ is processed into a corresponding string representing a valid SuperCollider UGen object.
For each resulting UGen we generate an intermediate variable.
These intermediate variables are used to connect the inputs and outputs of the generated UGens in order to avoid deeply nested UGens, and increase code readability.
During this process, the variable names are collected for later declaration, as SuperCollider requires all locally-scoped variables be declared at the beginning of a function.

Fig.~\ref{fig:sc_code} presents a valid SuperCollider $SynthDef$ that was generated by \ourTool.
The resulting SuperCollider program is encapsulated in a SynthDef, so that it can immediately be used by the user as a SuperCollider $synth$ to generate sound.
The generated program exposes the synthesized values for each of the $Nodes$, which allows for further tuning and expansion by the user.

