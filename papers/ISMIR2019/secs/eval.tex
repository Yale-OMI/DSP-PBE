\section{Evaluation}

To evaluate our approach, we apply our synthesis algorithm to two sets of input/output examples.
The first set examines the effectiveness of the initial structure construction as described in Sec~\ref{sec:initStruct}.
The second benchmark set captures the use case of \ourTool where a user wants to model real world sounds.
This set consists of examples where the input is a trumpet without a mute, and the output examples are the same trumpet with various mutes.


\begin{table}
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Input} & \textbf{Filter} & \textbf{dist(o, $f$(i))} & \textbf{Time (sec)}
\csvreader{results/farm.csv}{}
{\\ \hline \csvcoli & \csvcolii & \csvcoliv & \csvcolvi}
\\ \hline
\end{tabular}
\caption{The process for initial structure construction speeds up synthesis of simple filters.}
\label{table:evalInit}
\end{table}

The results of running \ourTool  on the trumpet mute sounds benchmarks are reported in Table~\ref{table:eval}.
This table was generates with the maximum structural attempts set to 6 and the maximum metrical attempts per structure set to 5.

\begin{table*}[]
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Input} & \textbf{Output} & \textbf{dist(o, $f$(i))} & \textbf{Structural Attempts} & \textbf{Time (sec)}
\csvreader{results/trumpet.csv}{}
{\\ \hline \csvcoli & \csvcolii & \csvcoliv & \csvcolv & \csvcolvi}
\\ \hline
\end{tabular}
\caption{Evaluation on a set of benchmarks.}
\label{table:eval}
\end{table*}

\subsection{SC3 Program Generation}

The generated model is not usable, nor alterable, by the user, so we present means to translate the produced filter into working SC3 code.
Each of the DSPNode types, except for $WhiteNoise$, are directly translatable into corresponding SC3 UGens. $WhiteNoise$ requires the addition of an implicit $Mix$ UGen, which mixes the incoming signal with the signal generated by the $WhiteNoise$.
The tree of $Filter\ Nodes$ is recursively traversed, and processed into a corresponding strings, each representing a valid SuperCollider UGen object.
The resulting UGens are connected through intermediate variables in order to avoid deeply nested UGens, and increase code readability.

Fig. X \sam{add fig above}  presents a valid SuperCollider $SynthDef$ that was generated by our translation program.
The resulting SC3 program is encapsulated in a SynthDef, so it can immediately be of use as a SC3 $synth$.
The generated program exposes the derived optimal values for each of the DSPNodes, which allows further tuning and expansion by the user.

\sam{should we have figures of an example generated supercollider program here ?}
