
\section{Introduction}

There has been a proliferation of new programming languages for audio Digital Signal Processing (DSP) including languages such as SuperCollider, Faust, MaxMSP, PureData.
These languages provide a high-level interface to make DSP programming more approachable for new-comers to the field of audio programming.
DSP programming poses a particular challenge to novice programmers, as writing a DSP program requires an understanding of traditional programming concepts such as loops and conditionals, as well as the ability to reason about DSP issues such as time vs frequency domain.
To assist beginning DSP programmers we turn to the Programming by Example paradigm.

Programming by Example (PBE) is a program synthesis technique that allows users to provide input and output examples to a system that then automatically generates code that implements the illustrated functionality.
This technique has found particular success in spreadsheets with the FlashFill tool~\cite{flashfill}.
In a similar way, we hope to make DSP programming more accessible to a larger audience by using Digital Signal Processing Programming by Example (DSP-PBE).
In order to do this, we extend prior work on DSP-PBE with the ability to generate SuperCollider programs, as well as the ability to support noncommutative filter types and various code structures.

The goal of DSP-PBE is to take an input and output audio example from the user, and synthesize the DSP program, $F$, that minimizes the distance between the transformed input, $F(i)$, and the output $o$.
In this way, a user can automatically generate the program code that captures the audio transformation demonstrated by the provided examples.
A key part of this technique is that the user receives readable DSP program code that can be further tuned or edited as the user sees fit, opening the door for learning opportunities and creative invention.


\subsection{Motivating Example}


\begin{figure}
\begin{lstlisting}
( 
SynthDef(\dsp_pbe, {|out=0|

   var main_in, id7, out6, lpf5, hpf4, psh1;
   main_in = PlayBuf.ar(2, ~buf);
   psh1 = FreqShift.ar(\pitchRatio, -399.999, 
                       \mul, 0.55, 
                       \in, In.ar());
   hpf4 = HPF.ar(\freq, 10100.0, 
                 \mul, 1.562e-10, 
                 \in, psh1);
   lpf5 = LPF.ar(\freq, 3860.002, 
                 \mul, 0.85, 
                 \in, psh1);
   out6 = Mix.ar(2, [hpf4, lpf5]);
   id7 = 0.7 * out6;
   Out.ar(out, id7);

}).add;
)
\end{lstlisting}
\caption{The SuperCollider program synthesized by \ourTool to simulate the effect of a trumpet hat mute.}
\label{fig:sc_code}
\end{figure}

A user may want to construct a program in order to apply the effect of a trumpet mute to another sound.
Rather than writing the code from scratch, we demonstrate the application of \ourTool by showing how the tool is used to build a SuperCollider program that mimics the effect of a trumpet mute.
To start, a user would provide an audio input example file of the trumpet without a mute (``00 none'' in Table~\ref{table:eval}), and an audio output example file (``01 hat'' in Table~\ref{table:eval}) of the trumpet playing the same note with the mute.
The user then invokes \ourTool on these two files, and the tool generates the SuperCollider program shown in Fig.~\ref{fig:sc_code}.
With this code, the user can then use the program directly in a larger SuperCollider project.
In addition, the user may wish to edit the code themselves - for example changing the \texttt{mul} argument to the \texttt{HPF} to a larger value.

In summary, this paper makes the following contributions.

\begin{enumerate}
\item We propose a framework for the synthesis of DSP programs that utilize noncommutative filter types 
\item We propose an algorithm to search through the possible structural forms of a DSP filter program
\item We present our tool, \ourTool, which synthesizes SuperCollider programs from audio input/output examples, and evaluate \ourTool over a set of benchmarks
\end{enumerate}


