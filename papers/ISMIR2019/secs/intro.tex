
\section{Introduction}

There has been a proliferation of new programming languages for audio Digital Signal Processing (DSP) with languages such as SuperCollider, Faust, MaxMSP, PureData.
These languages provide a high-level interface to make DSP programming more approachable for new-comers to the field of audio programming.
DSP programming poses a particular challenge to novice programmers as writing a DSP program requires an understanding of traditional programming concepts such as loops and conditionals, as well as the ability to reason about DSP issues such as time vs frequency domain.
To assist beginning DSP programmers we turn to the Programming by Example paradigm.

Programming by Example (PBE) is a program synthesis technique that allows users to provide input and output examples to system that then automatically generates code that models the illustrated functionality.
This technique has found particular success in spreadsheets with the FlashFill tool.
In a similar vein, we hope to make DSP programming more accessible to a larger audience by using Digital Signal Processing Programming by Example (DSP-PBE).

The goal of DSP-PBE is to take an input and output audio example from the user, and synthesize the DSP program, $F$, that minimizes the distance between the transformed input, $F(i)$, and the output $o$.
In this way, a user can automatically generate the program code that captures the audio transformation demonstrated by the provided examples.
A key part of this technique is that the user receives readable DSP program code that can be further tuned or edited as the user sees fit, opening the door for learning opportunities and creative invention.


\subsection{Motivating Example}


\begin{figure}
\begin{lstlisting}
( 
SynthDef(\dsp_pbe, {|out=0|

   var main_in, id7, out6, lpf5, hpf4, psh1;
   main_in = PlayBuf.ar(2, ~buf);
   psh1 = FreqShift.ar(pitchRatio: -399.999, 
                       mul: 0.55, 
                       in: In.ar());
   hpf4 = HPF.ar(freq: 10100.0, 
                 mul: 1.562e-10, 
                 in: psh1);
   lpf5 = LPF.ar(freq: 3860.002, 
                 mul: 0.85, 
                 in: psh1);
   out6 = Mix.ar(2, [hpf4, lpf5]);
   id7 = 0.7 * out6;
   Out.ar(out, id7);

}).add;
)
\end{lstlisting}
\caption{The SuperCollider program synthesized by \ourTool to simulate the effect of a trumpet hat mute.}
\label{fig:sc_code}
\end{figure}

We demonstrate the application of \ourTool by showing how the tool is used to build a SuperCollider program that mimics the effect of a trumpet mute.
A user may want to construct a program in order to apply the effect of a trumpet mute to another sound.
To start, a user would provide an audio input example file of the trumpet without a mute (``00 none'' in Table~\ref{table:eval}), and an audio output example file (``01 hat'' in Table~\ref{table:eval}) of the trumpet playing the same note with the mute.
The user then invokes \ourTool on these two files, and the tool generates the SuperCollider program shown in Fig.~\ref{fig:sc_code}.
With this code, the user can then use the program directly in a larger SuperCollider project.
In addition, the user may wish to edit the code themselves - for example changing the mul argument to the HPF to a larger value.

In summary, this paper makes the following contributions.

\begin{enumerate}
\item We propose framework for the synthesis of DSP programs that utilize noncommutative filter types 
\item We propose an algorithm for search through the possible structural forms of a DSP filter program
\item We present our tool, \ourTool, which synthesizes SuperCollider programs from audio input/output examples, and evaluate \ourTool over a set of benchmarks
\end{enumerate}


