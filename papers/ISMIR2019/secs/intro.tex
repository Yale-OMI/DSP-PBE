
\section{Introduction}

There has been a proliferation of new programming languages for audio Digital Signal Processing (DSP) including languages such as SuperCollider~\cite{supercollider}, Faust~\cite{orlarey2009faust}, and PureData~\cite{puredata}.
These languages provide a high-level interface to make DSP programming more approachable for new-comers to the field of audio programming.
DSP programming poses a particular challenge to novice programmers, as writing a DSP program requires an understanding of traditional programming concepts such as loops and conditionals, as well as the ability to reason about DSP issues such as time vs frequency domain.
To assist beginning DSP programmers we turn to the Programming by Example paradigm.

Programming by Example (PBE)~\cite{cypher93,lieberman01} is a program synthesis technique that allows users to provide input and output examples to a system that then automatically generates code that implements the illustrated functionality.
This technique has found particular success in spreadsheets with the FlashFill tool~\cite{flashfill}.
Similarly, we hope to make DSP programming more accessible to a larger audience by using Digital Signal Processing Programming by Example (DSP-PBE).
In order to do this, we introduce our tool, \ourTool, for DSP-PBE.
\ourTool extends prior work on DSP-PBE~\cite{SantolucitoFARM} with the ability to synthesize nontrivial filter types and generate a range of various code structures.
Additionally, \ourTool generates executable code, in SuperCollider, that allows the user to inspect, modify, and reuse the result of synthesis in their own coding projects.

The goal of DSP-PBE is to take an input and output audio example from the user, and synthesize the DSP program, $F$, that minimizes the distance between the transformed input, $F(i)$, and the output $o$.
With DSP-PBE, a user does not need to manually write code from scratch, but can simple provide audio files that demonstrates the desired functionality and the DSP-PBE tool will automatically generate the program code that captures the audio transformation.
A key part of this technique is that the user receives readable DSP program code that can be further tuned or edited as the user sees fit, opening the door for learning opportunities and creative invention.


\subsection{Motivating Example}


\begin{figure}
\begin{lstlisting}
( 
SynthDef(\dsp_pbe, {|out=0|

   var main_in, id7, out6, lpf5, hpf4, psh1;
   main_in = PlayBuf.ar(2, ~buf);
   psh1 = FreqShift.ar(\pitchRatio, -399.999, 
                       \mul, 0.55, 
                       \in, In.ar());
   hpf4 = HPF.ar(\freq, 10100.0, 
                 \mul, 1.562e-10, 
                 \in, psh1);
   lpf5 = LPF.ar(\freq, 3860.002, 
                 \mul, 0.85, 
                 \in, psh1);
   out6 = Mix.ar(2, [hpf4, lpf5]);
   id7 = 0.7 * out6;
   Out.ar(out, id7);

}).add;
)
\end{lstlisting}
\caption{The SuperCollider program synthesized by \ourTool to simulate the effect of a trumpet hat mute.}
\label{fig:sc_code}
\end{figure}

A user may want to construct a program in order to apply the effect of a trumpet mute to another sound.
Rather than writing the code from scratch, we demonstrate the application of \ourTool by showing how the tool is used to build a SuperCollider program that mimics the effect of a trumpet mute.
To start, a user would provide an audio input example file of the trumpet without a mute (``00 none'' in Table~\ref{table:eval}), and an audio output example file (``01 hat'' in Table~\ref{table:eval}) of the trumpet playing the same note with the mute.
The user then invokes \ourTool on these two files, and the tool generates the SuperCollider program shown in Fig.~\ref{fig:sc_code}.
With this code, the user can then use the program directly in a larger SuperCollider project.
In addition, the user may wish to edit the code themselves - for example changing the \texttt{mul} argument to the \texttt{HPF} to a larger value.

In summary, this paper makes the following contributions.

\begin{enumerate}
\item We propose a framework for the synthesis of DSP programs that utilize noncommutative filter types 
\item We propose an algorithm to search through the possible structural forms of a DSP filter program
\item We present our tool, \ourTool, which synthesizes SuperCollider programs from audio input/output examples, and evaluate \ourTool over a set of benchmarks
\end{enumerate}


