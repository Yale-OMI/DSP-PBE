\section{Structural Synthesis}
\label{sec:struct}

The structural synthesis stage of our algorithm consists of two parts.
First we guess at an initial filter structure based on a preliminary analysis of the input/output audio examples.
In the second stage, which occurs during the synthesis loop, we iteratively pick new structures to try during metrical synthesis.
For this second stage we have implemented a greedy algorithm to pick the best structure out of the possible next choices.

\subsection{Initial Structure Construction}
\label{sec:initStruct}
In order to find an initial structure for our synthesized filter, we use an adaption of room impulse response measurement.
When measuring the impulse response of a room, we can reconstruct the band-pass filter exactly by playing a sound in the room, recording the sound, then examining the differences.
In DSP-PBE, we do not want to allow infinitely many bandpass filters, as the synthesized program should be relatively small and human-readable, as code that might have been manually written.
Thus, we mimic the room impulse response measurement technique using only the available \dspnode in our grammar.

In the grammar listed in Fig.~\ref{fig:grammar}, we have two filters which are similar to the bandpass filters used in measuring room impulse response - a low-pass filter, $LFP \ [0,20k]\ [0,1]$, and a high-pass filter $HPF\ [0,20k]\ [0,1]$.
In order to quickly discover approximate values for each \dspnode, we run an analysis of the frequencies present in the input example that do not appear in the output example.

As an example, consider 
Concertizing the threshold constants of $LPF$ at a value of 1500 Hz, and the application constant at 1, we then get $LPF \ 1500 \ 1$.

Applying $LPF \ 1500 \ 1$ to an audio file with a flat frequency response look as follows:

We then build a relation from this observation, using a similar syntax to the refinement type system for Haskell, LiquidHaskell~\cite{vazou2014refinement}, 
Based on the above observation, we can write a refinement type on $LPF$ to describe that says the amplitude of the frequencies greater than the threshold frequency have decreased in the output Audio.
%
\begin{align*}
  &\texttt{lpf :: t:\reals} \to  \texttt{xs:Audio} \to\ \texttt{ys:Audio}\ \mid \\
  &\forall f_1 \in  \texttt{spectrogram(xs)}.\ \forall f_2 \in \texttt{spectrogram(ys)}. \\
  &(f_1 > \texttt{t}  \land  f_2 > \texttt{t}  \land f_1 == f_2) \implies \texttt{amp}(f_1) > \texttt{amp}(f_2)
\end{align*}

Where \texttt{t} represents the level at which the lowpass filter is applied, \texttt{spectrogram} represents the spectrogram of the sound sample, $f_i$ represents a frequency, and \texttt{amp()} represents the amplitude of the frequency. 

Similarly, we can build a relation to describe a high-pass filter as a refinement type that says the amplitude of the frequencies less than the threshold frequency have decreased in the output Audio.
%
\begin{align*}
  &\texttt{hpf :: t:\reals} \to\ \texttt{xs:Audio} \to\ \texttt{ys:Audio}\ \mid \\
  &(\forall f_1 \in \texttt{spectrogram(xs)}. \forall f_2 \in \texttt{spectrogram(ys)}). \\
  &(f_1 < \texttt{t} \land f_2 < \texttt{t} \land f_1 == f_2) \implies \texttt{amp(}f_1\texttt{)} > \texttt{amp(} f_2 \texttt{)} 
\end{align*}

Notice that in these refinement types, we only need to calculate the spectrogram for the input and output statically.
As opposed to the current technique of generating filters, applying them, and the calculating the aural distance, this approach is relatively static.
We could quickly check many threshold values over the input and output examples.

\subsection{Structural Synthesis}

\begin{figure}
\begin{align*}
	LPF \ 10000 \ 0.5 \arrComp HPF \ 100 \ 0.5 & \\
	\ldots & \arrComp PitchShift \ 0.1 \ 0.1 \\
	\ldots & \parallelCompose PitchShift \ 0.1 \ 0.1 \\
	\ldots & \arrComp Reverb \ 0.1 \ 0 \ 0.1 \\
	\ldots & \parallelCompose Reverb \ 0.1 \ 0 \ 0.1 \\
	\ldots & \arrComp WhiteNoise \ 0.1 \\
	\ldots & \parallelCompose WhiteNoise \ 0.1
\end{align*}
\caption{New structural candidates are generated based on all compositions of unused \dspnode}
\label{fig:generation}
\end{figure}

During each loop of our synthesis procedure, we attempt to build a new structure based on the results of our previous attempts.
We compare several different variations on the current structure (Fig.~\ref{fig:generation}).
Variations are generated by composing all \dspnode that are not present in the current structure with sequential and parallel composition onto the existing filter program returned from our metrical synthesis (cf. Sec.~\ref{sec:opt}).
We keep the parameters for the existing \dspnode, but for the new \dspnode we initialize the parameters to small values.
Using small values (instead of zeroes) ensures that the filter has an observable effect on the sound.
We score each of these filter programs, $f$, by the distance, $\distFxn(f(i), o)$, from their output to the output example file.
We then select the candidate filter program with the best score.
We continue this process until we either exceed our maximum allowed structural attempts or have reached a program whose output is close enough to the desired output.
