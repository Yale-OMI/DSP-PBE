\section{Structural Synthesis}
\label{sec:struct}

The structural synthesis stage of our algorithm consists of two parts.
First we guess at an initial filter structure based on a preliminary analysis of the input/output audio examples.
In the second stage, which occurs during the synthesis loop, we iteratively pick new structures to try during metrical synthesis.
For this second stage we have implemented a greedy algorithm to pick the best structure out of the possible next choices.

\subsection{Initial Structure Construction}
\label{sec:initStruct}
In order to find an initial structure for our synthesized filter, we use an adaption of room impulse response measurement.
When measuring the impulse response of a room, we can reconstruct the band-pass filter exactly by playing a sound in the room, recording the sound, then examining the differences.
In DSP-PBE, we do not want to allow infinitely many bandpass filters, as the synthesized program should be relatively small and human-readable, as code that might have been manually written.
Thus, we will mimic the room impulse response measurement technique using only the available $Nodes$ in our grammar.

In the grammar of our running example, we have two filters, a low-pass filter, $LFP \ [0,20k]\ [0,1]$, and a high-pass filter $HPF\ [0,20k]\ [0,1]$.
Concertizing the threshold constants of $LPF$ at a value of 1500 Hz, and the application constant at 1, we then get $LPF \ 1500 \ 1$.

Applying $LPF \ 1500 \ 1$ to an audio file with a flat frequency response look as follows:

We then build a relation from this observation, using a similar syntax to the refinement type system for Haskell, LiquidHaskell~\cite{vazou2014refinement}, 
Based on the above observation, we can write a refinement type on $LPF$ to describe that says the amplitude of the frequencies greater than the threshold frequency have decreased in the output Audio.
%
\begin{align*}
  &\texttt{lpf :: t:\reals} \to  \texttt{xs:Audio} \to\ \texttt{ys:Audio}\ \mid \\
  &\forall f_1 \in  \texttt{spectrogram(xs)}.\ \forall f_2 \in \texttt{spectrogram(ys)}. \\
  &(f_1 > \texttt{t}  \land  f_2 > \texttt{t}  \land f_1 == f_2) \implies \texttt{amp}(f_1) > \texttt{amp}(f_2)
\end{align*}

Where \texttt{t} represents the level at which the lowpass filter is applied, \texttt{spectrogram} represents the spectrogram of the sound sample, $f_i$ represents a frequency, and \texttt{amp()} represents the amplitude of the frequency. 

Similarly, we can build a relation to describe a high-pass filter as a refinement type that says the amplitude of the frequencies less than the threshold frequency have decreased in the output Audio.
%
\begin{align*}
  &\texttt{hpf :: t:\reals} \to\ \texttt{xs:Audio} \to\ \texttt{ys:Audio}\ \mid \\
  &(\forall f_1 \in \texttt{spectrogram(xs)}. \forall f_2 \in \texttt{spectrogram(ys)}). \\
  &(f_1 < \texttt{t} \land f_2 < \texttt{t} \land f_1 == f_2) \implies \texttt{amp(}f_1\texttt{)} > \texttt{amp(} f_2 \texttt{)} 
\end{align*}

Notice that in these refinement types, we only need to calculate the spectrogram for the input and output statically.
As opposed to the current technique of generating filters, applying them, and the calculating the aural distance, this approach is relatively static.
We could quickly check many threshold values over the input and output examples.

\subsection{Structural Synthesis}

During each loop of our synthesis procedure, we attempt to build a new structure based on the results of our previous attempts.
