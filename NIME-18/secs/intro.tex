\section{Introduction}

The great proliferation of computer music programming languages points to the difficulty of building a natural interface for users that want to computationally interact with musical data.
Programming applications in the domain of computer music, and specifically digital signal processing (DSP), requires that users not only grasp fundamental programming techniques, but also have a large domain specific knowledge on time and signal manipulations.
The amount of prerequisite skill and effort to overcome these barriers is often higher than many users are able to commit.

Furthermore, the difficult of programming DSP applications is often not commensurate with the creative intentions.
From a musical perspective, take the following simple use-case: a user hears a sample in a piece of music, and later in that piece hears the same sample with some added effects.
Now the user wishes to apply this same effect to their own sample.
In order to recreate this effect on a new sample, the user will have to reprogram the filter from the scratch.
This process will involve writing code, testing the code, listening to the original example, and constantly tweaking parameter values.

To simplify this process, we introduce \textit{DSP programming by example} (DSP-PBE).
In DSP programming by example, a user directly provides an input sound sample and an output sound sample, and a DSP-PBE tool will automatically construct the required program that represents a DSP filter that can transform the input sound into the output sound.

\subsection{Program Synthesis}
Programming by example, and program synthesis more generally, has experienced an explosion of research and progress in the last 15 years within the formal logic research community.
This has led to real world applications, such as FlashFill, a programming by example plugin for Microsoft Excel~\cite{flashfill}.

