{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}

module Synth where

import Codec.Wav

import FFT
import VividRunner
import Vivid

import Types.Common


data Filter = 
    HPF Float
  | LPF Float
  | Compose Filter Filter
  deriving (Show)

--wont type check for some reason
--toVivid :: Filter -> (Signal -> SDBody' x Signal)
toVivid = \case 
    HPF t -> (\bufs -> hpf (freq_ (t::Float), in_ bufs))
    LPF t -> (\bufs -> lpf (freq_ (t::Float), in_ bufs))
    Compose f f' -> (\bufs -> do ((toVivid f).(toVivid f')) bufs)

-- | generate the Vivid program to turn the in_example to the out_example
synthCode :: (FilePath, AudioFormat) -> (FilePath, AudioFormat) -> IO (Filter)
synthCode (in_filepath,in_audio) (out_filepath,out_audio) = do
  let f = toVivid $ LPF 200 
  testFilter in_filepath out_audio (f ::  Signal -> SDBody' '[] Signal)
  return (LPF 200)

testFilter :: FilePath -> AudioFormat -> (Signal -> SDBody' '[] Signal) -> IO AuralDistance
testFilter in_fp outAudio vividCode = do
  newOutFilepath <- runFilter in_fp vividCode
  newAudio <- importFile newOutFilepath :: IO(Either String AudioFormat)
  case newAudio of
    Left e -> error e
    Right a -> return $ peakResults outAudio a

-- Just one test filter for now, these will be generated by synthesis
lpFilter :: Float -> Signal -> SDBody' x Signal
lpFilter l bufStream =  do
  let myLPF bufs = lpf (freq_ (l::Float), in_ bufs)
  (myLPF . myLPF) bufStream
